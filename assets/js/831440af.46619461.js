"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7466],{4463:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>c,toc:()=>d});var s=t(4848),a=t(8453),i=t(1470),r=t(9365);const l={slug:"Library Design",title:"Library Design",authors:"freyk",tags:["fable","library","api","design","helper"]},o="Libary Design",c={permalink:"/Siren/blog/Library Design",editUrl:"https://github.com/Freymaurer/Siren/tree/main/docs/blog/2024-05-06-fable-library-design.mdx",source:"@site/blog/2024-05-06-fable-library-design.mdx",title:"Library Design",description:"Siren consists of one main code base written in F#. This code base is then transpiled to JavaScript, TypeScript, Python and made accessible from C#.",date:"2024-05-06T00:00:00.000Z",tags:[{label:"fable",permalink:"/Siren/blog/tags/fable"},{label:"library",permalink:"/Siren/blog/tags/library"},{label:"api",permalink:"/Siren/blog/tags/api"},{label:"design",permalink:"/Siren/blog/tags/design"},{label:"helper",permalink:"/Siren/blog/tags/helper"}],readingTime:23.31,hasTruncateMarker:!1,authors:[{name:"Kevin Frey",title:"Maintainer of Siren",url:"https://github.com/Freymaurer",imageURL:"https://github.com/Freymaurer.png",key:"freyk"}],frontMatter:{slug:"Library Design",title:"Library Design",authors:"freyk",tags:["fable","library","api","design","helper"]},unlisted:!1},h={authorsImageUrls:[void 0]},d=[{value:"Idea \ud83d\udca1",id:"idea-",level:2},{value:"What is Fable?",id:"what-is-fable",level:2},{value:"Benefits",id:"benefits",level:3},{value:"API Design",id:"api-design",level:2},{value:"Using <code>[&lt;AttachMembers&gt;]</code>",id:"using-attachmembers",level:3},{value:"C# Compatibility",id:"c-compatibility",level:3},{value:"Code generator helper",id:"code-generator-helper",level:4},{value:"Maintainability",id:"maintainability",level:4},{value:"Python/JavaScript import and Index files",id:"pythonjavascript-import-and-index-files",level:3},{value:"Publish",id:"publish",level:2},{value:".NET",id:"net",level:3},{value:"Pypi",id:"pypi",level:3},{value:"JavaScript (+Types)",id:"javascript-types",level:3},{value:"Deep Dive",id:"deep-dive",level:2},{value:"Overloads",id:"overloads",level:3},{value:"Erased Unions",id:"erased-unions",level:4},{value:"JavaScript optional parameters",id:"javascript-optional-parameters",level:3},{value:"Member Names",id:"member-names",level:3},{value:"F# reserved keywords",id:"f-reserved-keywords",level:4},{value:"C# - Member name = enclosing type",id:"c---member-name--enclosing-type",level:4},{value:"Transpiled names",id:"transpiled-names",level:4},{value:"Docs/Native Test Maintainance",id:"docsnative-test-maintainance",level:3}];function p(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Siren consists of one main code base written in F#. This code base is then transpiled to JavaScript, TypeScript, Python and made accessible from C#."}),"\n",(0,s.jsx)(n.admonition,{title:"Fable.Multiverse",type:"tip",children:(0,s.jsxs)(n.p,{children:["To make it as easy as possible to create a Fable library that publishes in multiple languages, I created a template called ",(0,s.jsx)(n.a,{href:"https://github.com/Freymaurer/Fable.Multiverse",children:"Fable.Multiverse"})," ","\ud83c\udf89"]})}),"\n",(0,s.jsx)(n.h2,{id:"idea-",children:"Idea \ud83d\udca1"}),"\n",(0,s.jsxs)(n.p,{children:["During a hackathon for our research data management consortium, we were discussing ideas for visualizing graph like structures in a way that allows easy gitlab integration and can be understood and used by any level of user. The idea we pursued was to add ",(0,s.jsx)(n.code,{children:".md"})," files with mermaid graphs for an easy overview. So why not write a domain specific language for mermaid graphs to make creation of such graphs easier and more error proof. Good idea, but what programming language should we use? In our consortium we have several groups, some using JavaScript, some Python, some (us) .NET or more specifically F#. Because i already have quite some experience using ",(0,s.jsx)(n.a,{href:"https://fable.io",children:"Fable"}),", i did the mental checklist to see if it would be a good fit for this project."]}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.em,{children:"Does not need any dependencies."})," Mermaid graphs, are mostly YAML, so no complex syntax."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.em,{children:"Does not require IO interaction."})," We can simply focus on writing our mermaid graph as string and allow the user to do whatever they want with it."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ",(0,s.jsx)(n.em,{children:"Only Fable compatible languages needed."})," We are already very happy offering such a tool in Python, JavaScript and F#."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:".. and thats it \ud83c\udf89 So we can start developing a libary with one codebase for 4 [5] languages."}),"\n",(0,s.jsx)(n.h2,{id:"what-is-fable",children:"What is Fable?"}),"\n",(0,s.jsxs)(n.p,{children:["Fable is a F# to X transpiler. It started out targeting only JavaScript, using a naming reference to the popular ",(0,s.jsx)(n.a,{href:"https://babeljs.io",children:"Babel"})," JavaScript transpiler. Now Fable aims to support multiple languages, all in different states. At the time of writing, the offical Fable docs state the following:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Language"}),(0,s.jsx)(n.th,{children:"Status"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"JavaScript"}),(0,s.jsx)(n.td,{children:"Stable"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"TypeScript"}),(0,s.jsx)(n.td,{children:"Stable"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Dart"}),(0,s.jsx)(n.td,{children:"Beta"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Python"}),(0,s.jsx)(n.td,{children:"Beta"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Rust"}),(0,s.jsx)(n.td,{children:"Alpha"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"PHP"}),(0,s.jsx)(n.td,{children:"Experimental"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"benefits",children:"Benefits"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Safety"}),". F# is a statically typed language, which means that the compiler can catch many errors before they even happen."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lightweight Syntax"}),". F# has a very lightweight syntax, which makes it easy to read and write. It does not require a lot of boilerplate code and you can get right into the meat of your program."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Testing(?)"}),". Main codebase is written in F# as well as most tests. This allows us to also transpile the tests to other languages and run them there. This is a big advantage, as we can be sure that the tests are the same in all languages."]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{title:"But why the question mark behind testing?",type:"note",children:(0,s.jsx)(n.p,{children:"Because we can recycle the tests, to ensure correct functionality, but we still must test if the library can be used from all supported languages without hurdles."})}),"\n",(0,s.jsx)(n.h2,{id:"api-design",children:"API Design"}),"\n",(0,s.jsx)(n.p,{children:"To make the code look and feel as native as possible in all languages, there are some things we need to consider. But first let us have a look at fable transpiled code."}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["The following code will use the ",(0,s.jsx)(n.a,{href:"https://fable.io/repl/",children:"Fable REPL"})," to transpile code for easy showcasing!"]})}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(r.A,{value:"fsharp",label:"F#",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fsharp",children:'let helloWorld = printfn "Hello World"\n'})})}),(0,s.jsx)(r.A,{value:"js",label:"JavaScript",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { printf, toConsole } from "fable-library-js/String.js";\n\nexport const helloWorld = toConsole(printf("Hello World"));\n'})})}),(0,s.jsx)(r.A,{value:"py",label:"Python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from fable_library_js.string import (to_console, printf)\n\nhello_world: None = to_console(printf("Hello World"))\n'})})})]}),"\n",(0,s.jsx)(n.p,{children:"We can already notice some things:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Fable tries to transpile into native syntax, so for example snake_case in Python and camelCase in JavaScript"}),"\n",(0,s.jsxs)(n.li,{children:["Fable has some wrappers for functions which might have native equivalents. In F# ",(0,s.jsx)(n.code,{children:"printfn"})," is used to print to the console, in JavaScript ",(0,s.jsx)(n.code,{children:"console.log"})," and in Python ",(0,s.jsx)(n.code,{children:"print"}),". But Fable uses their own printf function to ensure 100% correct f# transpilation."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Next we will have a look at a class with some member functions."}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(r.A,{value:"fsharp",label:"F#",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fsharp",children:"type MyClass =\n    static member add (x: int) (y: int) = x + y\n"})})}),(0,s.jsx)(r.A,{value:"js",label:"JavaScript",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { class_type } from "fable-library-js/Reflection.js";\n\nexport class MyClass {\n    constructor() {\n    }\n}\n\nexport function MyClass_$reflection() {\n    return class_type("Test.MyClass", undefined, MyClass);\n}\n\nexport function MyClass_add(x, y) {\n    return x + y;\n}\n'})})}),(0,s.jsx)(r.A,{value:"py",label:"Python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from fable_library_js.reflection import (TypeInfo, class_type)\n\ndef _expr0() -> TypeInfo:\n    return class_type("Test.MyClass", None, MyClass)\n\n\nclass MyClass:\n    ...\n\nMyClass_reflection = _expr0\n\ndef MyClass_add(x: int, y: int) -> int:\n    return x + y\n'})})})]}),"\n",(0,s.jsxs)(n.p,{children:["Oh no, this does not look good. Fable does a thing called ",(0,s.jsx)(n.a,{href:"https://fable.io/docs/javascript/features.html#name-mangling",children:(0,s.jsx)(n.em,{children:"name mangling"})}),".\nHave a look at the offical docs for a deeper view on this topic.\nFor now its enought to know, this is done to allow overloading functions in F#."]}),"\n",(0,s.jsxs)(n.h3,{id:"using-attachmembers",children:["Using ",(0,s.jsx)(n.code,{children:"[<AttachMembers>]"})]}),"\n",(0,s.jsx)(n.p,{children:"But we can tell Fable that we know what we are doing and ignore name mangling."}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(r.A,{value:"fsharp",label:"F#",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fsharp",children:"open Fable.Core\n\n[<AttachMembers>]\ntype MyClass =\n    static member add (x: int) (y: int) = x + y\n"})})}),(0,s.jsx)(r.A,{value:"js",label:"JavaScript",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { class_type } from "fable-library-js/Reflection.js";\n\nexport class MyClass {\n    constructor() {\n    }\n    static add(x, y) {\n        return x + y;\n    }\n}\n'})})}),(0,s.jsx)(r.A,{value:"py",label:"Python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from fable_library_js.reflection import (TypeInfo, class_type)\n\nclass MyClass:\n    @staticmethod\n    def add(x: int, y: int) -> int:\n        return x + y\n"})})})]}),"\n",(0,s.jsxs)(n.p,{children:["That looks better and allows us to do the following in all 3 languages: ",(0,s.jsx)(n.code,{children:"MyClass.add"}),".\nThis is the basic design i chose to use for most user facing api. All F#/Fable code not easily usable from other languages is hidden behind a facade like this."]}),"\n",(0,s.jsx)(n.h3,{id:"c-compatibility",children:"C# Compatibility"}),"\n",(0,s.jsxs)(n.p,{children:["Strangely enough allowing C# users the same ease of use as Python and JavaScript users is the hardest.\nThis is because C# has some issues with F# ",(0,s.jsx)(n.em,{children:"optional parameters"})," and F# ",(0,s.jsx)(n.em,{children:"tuples"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"In F# we can define a function like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fsharp",children:'[<AttachMembers>]\ntype flowchart =\n    static member raw (txt: string) = FlowchartElement txt\n    static member id (txt: string) = FlowchartElement txt\n    static member node (id: string, ?name: string) : FlowchartElement = ...\n\nflowchart.node("My id")\nflowchart.node("My id", "My name")\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Using the F# function in C# will result in an error, when you try to do ",(0,s.jsx)(n.code,{children:'flowchart.node("My id")'}),", as ",(0,s.jsx)(n.code,{children:"?name"})," is a ",(0,s.jsx)(n.code,{children:"Microsoft.FSharp.Core.FSharpOption<string>"})," without any default information."]}),"\n",(0,s.jsx)(n.p,{children:"By creating a C# access layer we can avoid this issue for C# users:"}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["The C# extensions for optional parameters and tuples are taken from ",(0,s.jsx)(n.a,{href:"https://github.com/plotly/Plotly.NET",children:"Plotly.NET"})," with the help from my dear colleague ",(0,s.jsx)(n.a,{href:"https://github.com/kMutagene",children:"Kevin Schneider"}),"."]})}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(r.A,{value:"flow",label:"Flowchart.cs",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public static class flowchart\n{\n    public static FlowchartElement raw(string txt) => Siren.flowchart.raw(txt);\n\n    public static FlowchartElement id(string txt) => Siren.flowchart.raw(txt);\n\n    public static FlowchartElement node(string id, Optional<string> name = default) =>\n        Siren.flowchart.node(id, name.ToOption());\n    //...\n}\n"})})}),(0,s.jsx)(r.A,{value:"fsharp",label:"OptionExtension.cs",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'/// <summary>\n/// Helper type for handling the special way the Plotly.NET core API uses generics.\n/// In short, the problem arises because many optional parameters of Plotly.NET\'s core API are generics \n/// with a type constraint for `IConvertible`. This means that these parameters can be both value and reference types \n/// (e.g. `double` and `System.DateTime` both implement IConvertible).\n/// If we now have a optional parameter of type `T? where T: IConvertible` the compiler will not allow this \n/// without further type constrainst to eithe reference or value type.\n/// This is a problem because we want to 1. allow both, and 2. have a reliable way of determining if the value was not set \n/// because the F# API expects to be passed `Option.None` in that case.\n/// There exist other workarounds like checking if the value is default or null, but that changes valid default values actually set to null as well.\n/// </summary>\n/// <typeparam name="T"></typeparam>\n/// <param name="Value">The value to mark as optional</param>\n/// <param name="IsSome">Wether or not the wrapped value is valid. This is used downstream to determine wether to wrap this value into `Option.Some` (if true) or `Option.None` (if false)</param>\npublic readonly record struct Optional<T>(T Value, bool IsSome)\n{\n    /// <summary>\n    /// \n    /// </summary>\n    /// <param name="Value"></param>\n    public static implicit operator Optional<T>(T Value) => new(Value, true);\n\n}\n/// <summary>\n/// Extension methods for the `Optional` class\n/// </summary>\npublic static class OptionalExtensions\n{\n    /// <summary>\n    /// Converts the `Optional` value to `Some(value)` if the value is valid, or `None` if it is not.\n    /// </summary>\n    /// <typeparam name="T"></typeparam>\n    /// <param name="opt">The `Optional` value to convert to a F# Option</param>\n    /// <returns>opt converted to `Option`</returns>\n    static internal Microsoft.FSharp.Core.FSharpOption<T> ToOption<T>(this Optional<T> opt) => opt.IsSome ? new(opt.Value) : Microsoft.FSharp.Core.FSharpOption<T>.None;\n}\n'})})})]}),"\n",(0,s.jsx)(n.p,{children:"A similar issue arises with F# tuples:"}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(r.A,{value:"flow",label:"Flowchart.fs",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fsharp",children:"[<AttachMembers>]\ntype flowchart =\n    static member stylesNode (nodeId: string, styles:#seq<string*string>) = Flowchart.formatNodeStyles [nodeId] (List.ofSeq styles) |> FlowchartElement\n"})})}),(0,s.jsx)(r.A,{value:"extension",label:"TupleExtension.cs",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"/// <summary>\n/// Convenience to convert from C# struct tuple literals to the value tuple ones.\n/// </summary>\ninternal static class TupleExtensions\n{\n    /// <summary>\n    /// Converts a tuple.\n    /// </summary>\n    internal static Tuple<T1, T2> ToTuple<T1, T2>(this ValueTuple<T1, T2> t) => Tuple.Create(t.Item1, t.Item2);\n}\n"})})}),(0,s.jsx)(r.A,{value:"fsharp",label:"Flowchart.cs",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"/// <summary>\n/// Convenience to convert from C# struct tuple literals to the value tuple ones.\n/// </summary>\npublic static class flowchart\n{\n    public static FlowchartElement stylesNode(string nodeId, (string, string)[] styles) =>\n        Siren.flowchart.stylesNode(nodeId, styles.Select(t => t.ToTuple()));\n}\n"})})})]}),"\n",(0,s.jsx)(n.h4,{id:"code-generator-helper",children:"Code generator helper"}),"\n",(0,s.jsx)(n.p,{children:"These incompatibilities are not only annoying but providing a consistently native C# experience, requires a wrapping for all apis.\nTo make this easier, i created a code generator that takes a F# file and generates the C# wrapper for it. .. Or at least 95% of it. The rest is done by hand."}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Code Generator"}),(0,s.jsx)("div",{children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fsharp",children:'open System.Reflection\n\n[<LiteralAttribute>]\nlet FSharpOptionDefault = "Optional<string>"\n\nlet transformParameterTypeName (paramTypeName: string)=\n    match paramTypeName with\n    | "String" -> "string"\n    | "Int32" -> "int"\n    | "Double" -> "double"\n    | "FSharpOption`1" -> FSharpOptionDefault // this is not always true but a good approximation\n    | "Tuple`2" -> "(string,string)" // this is not always true but a good approximation\n    | "Boolean" -> "bool"\n    | _ -> paramTypeName\n\ntype ParameterInfo = {\n    Type: string\n    Name: string\n} with\n    member this.FSharpParam =\n        match this with\n        | {Type = FSharpOptionDefault} -> this.Name + ".ToOption()"\n        | _ -> this.Name\n    member this.CSharpParam =\n       match this with\n       | {Type = FSharpOptionDefault} -> sprintf "%s %s = default" this.Type this.Name\n       | _ -> sprintf "%s %s" this.Type this.Name\n\n    static member create(typeName: string, name: string) =\n        {Type = transformParameterTypeName typeName; Name = name}\n\nlet generateCSharpCode<\'A>() =\n\n    let t = typeof<\'A>\n    let members = t.GetMethods(BindingFlags.Static ||| BindingFlags.Public)\n\n    let mutable csharpCode = sprintf "public static class %s\\n{\\n" t.Name\n    for m in members do\n        let methodName = \n            let name0 = m.Name\n            if name0.StartsWith("get_") then\n                name0.Substring(4)\n            else\n                name0\n        let returnType = m.ReturnType.Name\n        let params0 = \n            m.GetParameters() \n            |> Array.map (fun p -> ParameterInfo.create(p.ParameterType.Name, p.Name))\n        let csharpParameters =\n            if params0.Length = 0 then\n                ""\n            else    \n                params0\n                |> Array.map _.CSharpParam\n                |> String.concat(", ")\n                |> fun s -> "(" + s + ")"\n        \n        let fsharpParameters = \n            if params0.Length = 0 then\n                ""\n            else    \n                params0 \n                |> Array.map _.FSharpParam\n                |> String.concat(", ")\n                |> fun s -> "(" + s + ")"\n        \n        let methodSignature = $"public static {transformParameterTypeName returnType} {methodName}{csharpParameters}"\n        let methodBody = \n            if methodName.StartsWith("get_") then\n                let withoutGet = methodName.Substring(4)\n                $"return Siren.{t.Name}.{withoutGet};"\n            else\n                $" => Siren.{t.Name}.{methodName}{fsharpParameters};"\n        csharpCode <- csharpCode + $"    {methodSignature}\\n        {methodBody}\\n"\n\n    csharpCode <- csharpCode + "}\\n"\n    csharpCode\n\nlet test() = \n    generateCSharpCode<Siren.classDiagram>() // Here you can pass any type you want to generate C# code for\n    |> printfn "%A"\n'})})})]}),"\n",(0,s.jsx)(n.p,{children:"This is something i did not want to spend a lot of time on, so when i quickly wrote this and noticed it was able to create most of the C# code correctly.\nI think improving this code to create everything perfectly would be awesome, but would have taken me longer thant fixing the few mistakes it makes by hand."}),"\n",(0,s.jsx)(n.h4,{id:"maintainability",children:"Maintainability"}),"\n",(0,s.jsx)(n.p,{children:"This is a big issue. Whenever i update my f# api i must also update the c# wrapper.\nChanges are mostly catched by the compiler but missings functions are not."}),"\n",(0,s.jsx)(n.p,{children:"That is why i added unit tests to check the count and name of a c# and f# class and compare it for equality:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public static class Utils\n{\n    public static int GetMemberCount(Type type)\n    {\n        var members = type.GetMembers();\n        return members.Length;\n    }\n\n    public static List<string> GetMemberNameDifferences(Type type1, Type type2)\n    {\n        List<string> differences = new List<string>();\n        //transform string to lower\n        var type1Members = type1.GetMembers().Select(m => m.Name.ToLower());\n        var type2Members = type2.GetMembers().Select(m => m.Name.ToLower());\n        differences.AddRange(type1Members.Except(type2Members));\n        differences.AddRange(type2Members.Except(type1Members));\n\n        return differences;\n    }\n\n    public static void CompareClasses(Type csharpType, Type fsharpType)\n    {\n        int csharpMemberCount = GetMemberCount(csharpType);\n        int fsharpMemberCount = GetMemberCount(fsharpType);\n        List<string> differences = GetMemberNameDifferences(fsharpType, csharpType);\n\n        Assert.Empty(differences);\n        Assert.Equal(fsharpMemberCount, csharpMemberCount);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This at least helps me to catch missing functions in the c# wrapper, even if i still have to write them by hand."}),"\n",(0,s.jsx)(n.h3,{id:"pythonjavascript-import-and-index-files",children:"Python/JavaScript import and Index files"}),"\n",(0,s.jsxs)(n.p,{children:["F# and C# use namespaces to organize code. I can have multiple files with the same namespace and access all functions simply by writing ",(0,s.jsx)(n.code,{children:"open Siren"}),"/",(0,s.jsx)(n.code,{children:"using Siren.Sea;"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"In Python and JavaScript this is not possible. Here imports happen on a file basis. So i needed to have a single file that imports all other files and exports them."}),"\n",(0,s.jsx)(n.p,{children:"Luckily this file can be created automatically!"}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Index File"}),(0,s.jsx)("div",{children:(0,s.jsxs)(i.A,{children:[(0,s.jsx)(r.A,{value:"util",label:"Util.fs",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fsharp",children:'module Index.Util\n\nopen System\nopen System.IO\nopen System.Text.RegularExpressions\n\ntype FileInformation = {\n    FilePath : string\n    Lines : string []\n} with\n    static member create(filePath: string, lines: string []) = {\n        FilePath = filePath\n        Lines = lines\n    }\n\nlet getAllFiles(path: string, extension: string) = \n    let options = EnumerationOptions()\n    options.RecurseSubdirectories <- true\n    IO.Directory.EnumerateFiles(path,extension,options)\n    |> Seq.filter (fun s -> s.Contains("fable_modules") |> not)\n    |> Array.ofSeq\n\nlet findClasses (rootPath: string) (cois: string []) (regexPattern: string -> string) (filePaths: seq<string>) = \n    let files = [|\n        for fp in filePaths do\n            yield FileInformation.create(fp, System.IO.File.ReadAllLines (fp))\n    |]\n    let importStatements = ResizeArray()\n    let findClass (className: string) = \n        /// maybe set this as default if you do not want any whitelist\n        let classNameDefault = @"[a-zA-Z_0-9]"\n        let pattern = Regex.Escape(className) |> regexPattern\n        let regex = Regex(pattern)\n        let mutable found = false\n        let mutable result = None\n        let enum = files.GetEnumerator()\n        while not found && enum.MoveNext() do\n            let fileInfo = enum.Current :?> FileInformation\n            for line in fileInfo.Lines do\n                let m = regex.Match(line)\n                match m.Success with\n                | true -> \n                    found <- true\n                    result <- Some <| (className, IO.Path.GetRelativePath(rootPath,fileInfo.FilePath))\n                | false ->\n                    ()\n        match result with\n        | None ->\n            failwithf "Unable to find %s" className\n        | Some r ->\n            importStatements.Add r\n    for coi in cois do findClass coi\n    importStatements\n    |> Array.ofSeq\n\nlet writeIndexFile (path: string) (fileName: string) (content: string) =\n    let filePath = Path.Combine(path, fileName)\n    File.WriteAllText(filePath, content)\n'})})}),(0,s.jsx)(r.A,{value:"js",label:"Indexjs.fs",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fsharp",children:'module Index.JS\n\nlet private getAllJsFiles (path: string) fileExtension = \n    Util.getAllFiles(path,$"*.{fileExtension}")\n\nlet private pattern (className: string) = sprintf @"^export class (?<ClassName>%s)+[\\s{].*({)?" className\n\nlet private findJsClasses (rootPath: string) (whiteList: string []) (filePaths: string []) = \n    Util.findClasses rootPath whiteList pattern filePaths\n\nopen System.Text\n\nlet private createImportStatements (info: (string*string) []) =\n    let sb = StringBuilder()\n    let importCollection = info |> Array.groupBy snd |> Array.map (fun (p,a) -> p, a |> Array.map fst )\n    for filePath, imports in importCollection do\n        let p = filePath.Replace("\\\\","/").Replace("ts","js")\n        sb.Append "export { " |> ignore\n        sb.AppendJoin(", ", imports) |> ignore\n        sb.Append " } from " |> ignore\n        sb.Append (sprintf "\\"./%s\\"" p) |> ignore\n        sb.Append ";" |> ignore\n        sb.AppendLine() |> ignore\n    sb.ToString()\n\nlet private generateIndexfile (rootPath: string, fileName: string, whiteList: string [], fileExtension: string) =\n    getAllJsFiles rootPath fileExtension\n    |> findJsClasses rootPath whiteList\n    |> createImportStatements\n    |> Util.writeIndexFile rootPath fileName\n\nlet generate(rootPath: string) (ts: bool) = \n    let extension = if ts then "ts" else "js"\n    generateIndexfile(rootPath, $"index.{extension}", WhiteList.WhiteList, extension)\n'})})}),(0,s.jsx)(r.A,{value:"py",label:"Indexpy.fs",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fsharp",children:'open System\nopen System.IO\n\nlet private getAllJsFiles(path: string) = \n    Util.getAllFiles(path,"*.py")\n\nlet private pattern (className: string) = sprintf @"^class (?<ClassName>%s)+(\\(|:).*$" className\n\nlet private findPyClasses (rootPath: string) (whiteList: string []) (filePaths: string []) = \n    Util.findClasses rootPath whiteList pattern filePaths\n\nopen System.Text\n\nlet private createImportStatements (info: (string*string) []) =\n    let sb = StringBuilder()\n    let importCollection = info |> Array.groupBy snd |> Array.map (fun (p,a) -> p, a |> Array.map fst )\n    for filePath, imports in importCollection do\n        let p = filePath |> Path.GetFileNameWithoutExtension\n        sb.Append (sprintf "from .%s import " p) |> ignore\n        sb.AppendJoin(", ", imports) |> ignore\n        sb.AppendLine() |> ignore\n    sb.ToString()\n\nlet private generateIndexfile (rootPath: string, fileName: string, whiteList: string []) =\n    getAllJsFiles(rootPath)\n    |> findPyClasses rootPath whiteList\n    |> createImportStatements\n    |> Util.writeIndexFile rootPath fileName\n\nlet generate(rootPath: string) = \n    // code to make camelcase to snakecase\n    /// This is because we currently snake_case everything that does not start with a capital letter\n    let camelCaseToSnakeCase (str: string) = \n        if Char.IsUpper str.[0] then\n            str \n        else\n            str \n            |> Seq.fold (fun (acc: string) c -> \n                if Char.IsUpper c then \n                    acc + "_" + string (Char.ToLower c) \n                else \n                    acc + string c\n            ) ""\n    let snake_case_white_list = WhiteList.WhiteList |> Array.map camelCaseToSnakeCase\n    generateIndexfile(rootPath, "index.py", snake_case_white_list)\n'})})}),(0,s.jsx)(r.A,{value:"whitelist",label:"WhiteList.fs",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fsharp",children:'module Index.WhiteList\n\nlet WhiteList = [|\n    "SirenElement"\n    // ThemeVaruiables\n    "themeVariable"\n    "quadrantTheme"; \n    "gitTheme"; \n    "timelineTheme"; \n    "xyChartTheme"; \n    "pieTheme";\n    // Config\n    "graphConfig";\n    "flowchartConfig"; \n    "sequenceConfig"; \n    "ganttConfig"; \n    "journeyConfig"; \n    "timelineConfig"; \n    "classConfig"; \n    "stateConfig"; \n    "erConfig"; \n    "quadrantChartConfig"; \n    "pieConfig"; \n    "sankeyConfig"; \n    "xyChartConfig"; \n    "mindmapConfig"; \n    "gitGraphConfig"; \n    "requirementConfig"; \n    // Graphs and Helpers\n    "formatting"; \n    "direction"; \n    "flowchart"; \n    "notePosition"; \n    "sequence"; \n    "classMemberVisibility"; \n    "classMemberClassifier"; \n    "classDirection"; \n    "classCardinality"; \n    "classRltsType"; \n    "classDiagram"; \n    "stateDiagram"; \n    "erKey"; \n    "erCardinality"; \n    "erDiagram"; \n    "journey"; \n    "ganttTime"; \n    "ganttTags"; \n    "ganttUnit"; \n    "gantt"; \n    "pieChart"; \n    "quadrant"; \n    "rqRisk"; \n    "rqMethod"; \n    "requirement"; \n    "gitType"; \n    "git"; \n    "mindmap"; \n    "timeline"; \n    "sankey"; \n    "xyChart"; \n    "block"; \n    "theme"; \n    "siren"; \n|]\n'})})})]})})]}),"\n",(0,s.jsx)(n.p,{children:"The resulting files look like this:"}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(r.A,{value:"js",label:"index.js",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'export { SirenElement } from "./SirenTypes.js";\nexport { themeVariable, quadrantTheme, gitTheme, timelineTheme, xyChartTheme, pieTheme } from "./ThemeVariables.js";\nexport { graphConfig, flowchartConfig, sequenceConfig, ganttConfig, journeyConfig, timelineConfig, classConfig, stateConfig, erConfig, quadrantChartConfig, pieConfig, sankeyConfig, xyChartConfig, mindmapConfig, gitGraphConfig, requirementConfig } from "./Config.js";\nexport { formatting, direction, flowchart, notePosition, sequence, classMemberVisibility, classMemberClassifier, classDirection, classCardinality, classRltsType, classDiagram, stateDiagram, erKey, erCardinality, erDiagram, journey, ganttTime, ganttTags, ganttUnit, gantt, pieChart, quadrant, rqRisk, rqMethod, requirement, gitType, git, mindmap, timeline, sankey, xyChart, block, theme, siren } from "./Siren.js";\n'})})}),(0,s.jsx)(r.A,{value:"py",label:"index.py",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",children:"from .siren_types import SirenElement\nfrom .theme_variables import theme_variable, quadrant_theme, git_theme, timeline_theme, xy_chart_theme, pie_theme\nfrom .config import graph_config, flowchart_config, sequence_config, gantt_config, journey_config, timeline_config, class_config, state_config, er_config, quadrant_chart_config, pie_config, sankey_config, xy_chart_config, mindmap_config, git_graph_config, requirement_config\nfrom .siren import formatting, direction, flowchart, note_position, sequence, class_member_visibility, class_member_classifier, class_direction, class_cardinality, class_rlts_type, class_diagram, state_diagram, er_key, er_cardinality, er_diagram, journey, gantt_time, gantt_tags, gantt_unit, gantt, pie_chart, quadrant, rq_risk, rq_method, requirement, git_type, git, mindmap, timeline, sankey, xy_chart, block, theme, siren\n"})})})]}),"\n",(0,s.jsx)(n.h2,{id:"publish",children:"Publish"}),"\n",(0,s.jsx)(n.p,{children:"As soon as we get to the publishing step everything is back to standard for the respective languages."}),"\n",(0,s.jsx)(n.h3,{id:"net",children:".NET"}),"\n",(0,s.jsxs)(n.p,{children:["The easiest. We already have the required project files, no need to transpile. So we can simply use ",(0,s.jsx)(n.code,{children:"dotnet pack"})," to create .nupkg files.\nThen ",(0,s.jsx)(n.code,{children:"dotnet nuget push"})," to push to ",(0,s.jsx)(n.a,{href:"https://www.nuget.org",children:"nuget.org"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"These are not the exact CLI args used. Details can be found in the build project in the GitHub repository."})}),"\n",(0,s.jsx)(n.h3,{id:"pypi",children:"Pypi"}),"\n",(0,s.jsxs)(n.p,{children:["Also quite easy. Transpile f# code to python code, copy ",(0,s.jsx)(n.code,{children:"pyproject.toml"})," and ",(0,s.jsx)(n.code,{children:"README.md"})," into the ",(0,s.jsx)(n.code,{children:"dist"})," folder and create ",(0,s.jsx)(n.code,{children:"index.py"})," file.\nRun ",(0,s.jsx)(n.code,{children:"python -m poetry build"})," to create a publishing files. Then publish files with ",(0,s.jsx)(n.code,{children:"python -m poetry publish"})]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"These are not the exact CLI args used. Details can be found in the build project in the GitHub repository."})}),"\n",(0,s.jsx)(n.h3,{id:"javascript-types",children:"JavaScript (+Types)"}),"\n",(0,s.jsxs)(n.p,{children:["For this i followed the Example of ",(0,s.jsx)(n.a,{href:"https://fable.io/blog/2023/2023-04-20-Better_Typed_than_Sorry.html",children:"Better Typed than Sorry"})," by ",(0,s.jsx)(n.a,{href:"https://github.com/alfonsogarciacaro",children:"Alfonso Garc\xeda-Caro"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Transpile F# to TypeScript, then use ",(0,s.jsx)(n.code,{children:"tsc"})," to transpile TypeScript to JavaScript and type information files (",(0,s.jsx)(n.code,{children:"*.d.ts"}),"). Add the ",(0,s.jsx)(n.code,{children:"index.js"})," file to the ",(0,s.jsx)(n.code,{children:"dist folder"}),"\nThen publish to npm with ",(0,s.jsx)(n.code,{children:"npm publish"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"These are not the exact CLI args used. Details can be found in the build project in the GitHub repository."})}),"\n",(0,s.jsx)(n.h2,{id:"deep-dive",children:"Deep Dive"}),"\n",(0,s.jsx)(n.p,{children:"From here on are some additional issues i encountered during development."}),"\n",(0,s.jsx)(n.h3,{id:"overloads",children:"Overloads"}),"\n",(0,s.jsxs)(n.p,{children:["The concept of allowing different inputs for the same function exists in f#, as well as python and javascript.\nBy using the ",(0,s.jsx)(n.code,{children:"[<AttachMembers>]"})," attribute we are not longer allowed to use standard f# overloads.\nBecause JavaScript does not have the same kind of type interference it is unable to recognice which function should be invoked:"]}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(r.A,{value:"fsharp",label:"F#",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fsharp",children:'open Fable.Core\n\n[<AttachMembers>]\ntype MyClass =\n    static member add (x: int, y: int) = x * y // this should be invoked\n    static member add (x: string, y: string) = x + y\n\nlet result = MyClass.add(10, 20)\n\nprintfn "%A" result\n'})})}),(0,s.jsx)(r.A,{value:"js",label:"JavaScript",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { class_type } from "fable-library-js/Reflection.js";\nimport { printf, toConsole } from "fable-library-js/String.js";\n\nexport class MyClass {\n    constructor() {\n    }\n    static add(x, y) {\n        return x * y;\n    }\n    static add(x, y) { // This shadows the function above and is invoked\n        return x + y;\n    }\n}\n\nexport const result = MyClass.add(10, 20); // This will return 30\n\ntoConsole(printf("%A"))(result);\n\n'})})})]}),"\n",(0,s.jsx)(n.h4,{id:"erased-unions",children:"Erased Unions"}),"\n",(0,s.jsxs)(n.p,{children:["It is possible to imitate js overload behaviour by using ",(0,s.jsx)(n.a,{href:"https://fable.io/docs/javascript/features.html#erased-unions",children:"erased unions"}),".\nHere we use a Fable provides discriminate union called ",(0,s.jsx)(n.code,{children:"U2"}),"(",(0,s.jsx)(n.code,{children:"U3"}),", ",(0,s.jsx)(n.code,{children:"U4"}),"...). After transpilation it is replaced by a js type check."]}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(r.A,{value:"fsharp",label:"F#",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fsharp",children:'open Fable.Core\nopen Fable.Core.JsInterop\n\n[<AttachMembers>]\ntype MyClass =\n    static member test (arg: U2<string, int>) = \n        match arg with\n        | U2.Case1 s -> printfn "This is a string: %s" s\n        | U2.Case2 i -> printfn "This is a integer: %i" i\n\nlet result = MyClass.test(U2.Case2 10) // or MyClass.test(!^10)\n\nprintfn "%A" result\n'})})}),(0,s.jsx)(r.A,{value:"js",label:"JavaScript",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { printf, toConsole } from "fable-library-js/String.js";\nimport { class_type } from "fable-library-js/Reflection.js";\n\nexport class MyClass {\n    constructor() {\n    }\n    static test(arg) {\n        if (typeof arg === "number") {\n            const i = arg;\n            toConsole(printf("This is a integer: %i"))(i);\n        }\n        else {\n            const s = arg;\n            toConsole(printf("This is a string: %s"))(s);\n        }\n    }\n}\n\nexport const result = MyClass.test(10);\n\ntoConsole(printf("%A"))(); // This is a integer: 10\n'})})})]}),"\n",(0,s.jsx)(n.p,{children:"As you can see, this looks really nice in JavaScript, but is cumbersome to use in F#."}),"\n",(0,s.jsx)(n.p,{children:"It would be possible to do do both and use f# overloads and shadow them with the erased union. But this would add more additional maintainance work."}),"\n",(0,s.jsxs)(n.admonition,{title:"Compiler Statements",type:"info",children:[(0,s.jsxs)(n.p,{children:["We can use ",(0,s.jsx)(n.code,{children:"#if FABLE_COMPILER ... #else ... #endif"})," syntax to include code only in certain compiler states."]}),(0,s.jsx)(n.p,{children:"In the following example the erased union is only used (and accessible!) when the code is transpiled by Fable to JavaScript."})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fsharp",children:'[<AttachMembers>]\ntype MyClass =\n// highlight-next-line\n#if FABLE_COMPILER_JAVASCRIPT\n    static member test (arg: U2<string, int>) = \n        match arg with\n        | U2.Case1 s -> printfn "This is a string: %s" s\n        | U2.Case2 i -> printfn "This is a integer: %i" i\n// highlight-next-line\n#else\n    static member test(arg: int) =\n        printfn "This is a integer: %i" arg\n    static member test(arg: string) =\n        printfn "This is a string: %s" arg\n// highlight-next-line\n#endif\n\nlet result = MyClass.test(10)\n'})}),"\n",(0,s.jsx)(n.p,{children:"This would allow us to use the erased union only in JavaScript and use the F# overloads in F#. But i have not investigated how this would work for python \ud83d\ude05."}),"\n",(0,s.jsx)(n.p,{children:"Due to the additional workload i decided to avoid using overloads in the api. Instead i tried finding the core functions and functions, which allow additional inputs with a different name:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fsharp",children:"type sequence =\n    static member note(id: string, text: string, ?notePosition: NotePosition) = //..\n    static member noteSpanning(id1: string, id2, text: string, ?notePosition: NotePosition) = //..\n"})}),"\n",(0,s.jsx)(n.h3,{id:"javascript-optional-parameters",children:"JavaScript optional parameters"}),"\n",(0,s.jsx)(n.p,{children:"Using functions with multiple optional parameters is easily done in F#, C# and Python, but can get quite annoying in JavaScript:"}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(r.A,{value:"js",label:"JavaScript",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// tripple null ...\nrequirement.requirement("my id", null, null, null, rqMethod.test)\n'})})}),(0,s.jsx)(r.A,{value:"f",label:"F#",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fsharp",children:'// easy!\nrequirement.requirement("My Id", rqMethod = rqMethod.analysis)\n'})})}),(0,s.jsx)(r.A,{value:"py",label:"Python",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# easy!\nrequirement.requirement("My Id", rq_method = rq_method.analysis)\n'})})}),(0,s.jsx)(r.A,{value:"c",label:"C#",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// easy!\nRequirement.requirement("My Id", rqMethod: rqMethod.analysis)\n'})})})]}),"\n",(0,s.jsxs)(n.p,{children:["The JavaScript native approach would be using an object with only the values you want to set.\nThere is even a way to tell Fable to transpile parameters as object using the ",(0,s.jsx)(n.code,{children:"[ParamObject]"})," attribute."]}),"\n",(0,s.jsxs)(i.A,{children:[(0,s.jsx)(r.A,{value:"f",label:"F#",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fsharp",children:'open Fable.Core\nopen Fable.Core.JsInterop\n\n[<AttachMembers>]\ntype MyClass =\n    [<ParamObject(1)>] // Start creating obj from params at index 1\n    static member test (name: int, ?id: string, ?text: string, ?rqRisk: string, ?rqMethod: string) =\n        0\n\n\nMyClass.test(10, rqRisk = "Hello")\nMyClass.test(10)\n'})})}),(0,s.jsx)(r.A,{value:"js",label:"JavaScript",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { class_type } from "fable-library-js/Reflection.js";\n\nexport class MyClass {\n    constructor() {\n    }\n    static test(name, { id, text, rqRisk, rqMethod }) {\n        return 0;\n    }\n}\n\nMyClass.test(10, {\n    rqRisk: "Hello",\n});\n\nMyClass.test(10, {}); // Oh oh. Why an empty object?\n'})})})]}),"\n",(0,s.jsxs)(n.p,{children:["As you can see adding ",(0,s.jsx)(n.em,{children:"no"})," optional parameters requires an empty object, as Fable checks if the value at object key xyz is null and not if the object is null.\nWithout the empty object the function would throw an error, whenever any of the optional parameters is referenced in the function. (Bad example as i just return 0)."]}),"\n",(0,s.jsx)(n.h3,{id:"member-names",children:"Member Names"}),"\n",(0,s.jsx)(n.p,{children:"Different languages have different expectations for member names. Aside from styling best practises, there are some things that are not possible in all languages."}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"F# typically uses PascalCase for class names and camelCase for member names.\nFor easier usage i ignore this rule and used camelCase for everything."})}),"\n",(0,s.jsx)(n.h4,{id:"f-reserved-keywords",children:"F# reserved keywords"}),"\n",(0,s.jsx)(n.p,{children:"The first issue i encountered where reserved keywords in F#."}),"\n",(0,s.jsxs)(n.p,{children:["For example ",(0,s.jsx)(n.code,{children:"classDiagram.``class``"}),". ",(0,s.jsx)(n.em,{children:'"class"'})," is a reserved keyword which is not allowed in F#.\nThe standard solution is wrapping the name in backticks. But at least for me on VisualStudio Community this resulted in issues with my auto complete.\nThis resulted in me handling this issue inconsistently. The issues i encountered were mostly in (optional) parameters, which is why i changed their names to PascalCase:"]}),"\n",(0,s.jsx)(n.p,{children:"For members i mostly stayed true to the backtick syntax."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fsharp",children:"[<AttachMembers>]\ntype classMemberClassifier =\n    // abstract is a reserved keyword\n    static member Abstract = ClassMemberClassifier.Abstract\n    // static is a reserved keyword\n    static member Static = ClassMemberClassifier.Static\n    static member custom str = ClassMemberClassifier.Custom str\n\n[<AttachMembers>]\ntype classDiagram =\n    static member ``class`` (id: string, members: #seq<ClassDiagramElement>) = \n"})}),"\n",(0,s.jsxs)(n.p,{children:["The C# wrapper used the C# best practise syntax ",(0,s.jsx)(n.code,{children:"@class"}),", which worked fine for me."]}),"\n",(0,s.jsx)(n.h4,{id:"c---member-name--enclosing-type",children:"C# - Member name = enclosing type"}),"\n",(0,s.jsxs)(n.p,{children:["I encountered this issue first for ",(0,s.jsx)(n.code,{children:"block.block"}),". In C# member names are not allowed to be the same as the enclosing type."]}),"\n",(0,s.jsxs)(n.p,{children:["As i am not a very experienced C# developer, i am still rather undecided on how to handle this issue.\nSo far I have been using ",(0,s.jsx)(n.code,{children:"Block.block"}),", as I am thinking about using PascalCase for all classes in C#. And if only to mute the warnings in VS Community."]}),"\n",(0,s.jsx)(n.p,{children:"If you have a strong opinion about this topic, please let me know! I am interested in hearing your thoughts."}),"\n",(0,s.jsx)(n.h4,{id:"transpiled-names",children:"Transpiled names"}),"\n",(0,s.jsxs)(n.p,{children:["And back to ",(0,s.jsx)(n.code,{children:"classDiagram.``class`` "}),". While JavaScript does not seem to care about this topic to much, Python does."]}),"\n",(0,s.jsxs)(n.p,{children:["JavaScript gives us the best result, the F# backtick syntax is transpiled to a simple camelCase name ",(0,s.jsx)(n.code,{children:"classDiagram.class"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Python on the other hand has ",(0,s.jsx)(n.code,{children:"class"})," also as reserved keyword. Fable transpiles it to ",(0,s.jsx)(n.code,{children:"classDiagram.class_"}),".\nWhich raises the question if i should simply apply this syntax to all cases with naming problems."]}),"\n",(0,s.jsx)(n.h3,{id:"docsnative-test-maintainance",children:"Docs/Native Test Maintainance"}),"\n",(0,s.jsxs)(n.p,{children:["The core library + C# wrapper were done rather quickly. I can also recycle my F# unit tests to check if transpilation works as expected, using ",(0,s.jsx)(n.a,{href:"https://github.com/Freymaurer/Fable.Pyxpecto",children:"Fable.Pyxpecto"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"But testing correct native accessibillity and writing docs (showcasing the test cases) was the most time consuming part and something i am not happy with."}),"\n",(0,s.jsx)(n.p,{children:"Here are some ideas on how to improve this:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Theoretically, i could use the transpiled tests for docs. But i still have to remove the Fable specific helper functions and replace them with native ones."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:(0,s.jsx)(n.a,{href:"https://github.com/kMutagene",children:"Kevin S."})})," had an idea, repurposing jupyter notebooks for docs and testing. To at least unify the testing and docs."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If you have any ideas on how to improve this, please let me know!"}),"\n"]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},9365:(e,n,t)=>{t.d(n,{A:()=>r});t(6540);var s=t(4164);const a={tabItem:"tabItem_Ymn6"};var i=t(4848);function r(e){let{children:n,hidden:t,className:r}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,s.A)(a.tabItem,r),hidden:t,children:n})}},1470:(e,n,t)=>{t.d(n,{A:()=>w});var s=t(6540),a=t(4164),i=t(3104),r=t(6347),l=t(205),o=t(7485),c=t(1682),h=t(9466);function d(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:t}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return d(e).map((e=>{let{props:{value:n,label:t,attributes:s,default:a}}=e;return{value:n,label:t,attributes:s,default:a}}))}(t);return function(e){const n=(0,c.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function u(e){let{queryString:n=!1,groupId:t}=e;const a=(0,r.W6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,o.aZ)(i),(0,s.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(a.location.search);n.set(i,e),a.replace({...a.location,search:n.toString()})}),[i,a])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,i=p(e),[r,o]=(0,s.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const s=t.find((e=>e.default))??t[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:i}))),[c,d]=u({queryString:t,groupId:a}),[g,f]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[a,i]=(0,h.Dv)(t);return[a,(0,s.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:a}),y=(()=>{const e=c??g;return m({value:e,tabValues:i})?e:null})();(0,l.A)((()=>{y&&o(y)}),[y]);return{selectedValue:r,selectValue:(0,s.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);o(e),d(e),f(e)}),[d,f,i]),tabValues:i}}var f=t(2303);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(4848);function x(e){let{className:n,block:t,selectedValue:s,selectValue:r,tabValues:l}=e;const o=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.a_)(),h=e=>{const n=e.currentTarget,t=o.indexOf(n),a=l[t].value;a!==s&&(c(n),r(a))},d=e=>{let n=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{const t=o.indexOf(e.currentTarget)+1;n=o[t]??o[0];break}case"ArrowLeft":{const t=o.indexOf(e.currentTarget)-1;n=o[t]??o[o.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":t},n),children:l.map((e=>{let{value:n,label:t,attributes:i}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,ref:e=>o.push(e),onKeyDown:d,onClick:h,...i,className:(0,a.A)("tabs__item",y.tabItem,i?.className,{"tabs__item--active":s===n}),children:t??n},n)}))})}function j(e){let{lazy:n,children:t,selectedValue:a}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===a));return e?(0,s.cloneElement)(e,{className:"margin-top--md"}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==a})))})}function v(e){const n=g(e);return(0,b.jsxs)("div",{className:(0,a.A)("tabs-container",y.tabList),children:[(0,b.jsx)(x,{...e,...n}),(0,b.jsx)(j,{...e,...n})]})}function w(e){const n=(0,f.A)();return(0,b.jsx)(v,{...e,children:d(e.children)},String(n))}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var s=t(6540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);