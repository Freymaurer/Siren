"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2338],{6426:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"Library Design","metadata":{"permalink":"/Siren/blog/Library Design","editUrl":"https://github.com/Freymaurer/Siren/tree/main/docs/blog/2024-05-06-fable-library-design.mdx","source":"@site/blog/2024-05-06-fable-library-design.mdx","title":"Library Design","description":"Siren consists of one main code base written in F#. This code base is then transpiled to JavaScript, TypeScript, Python and made accessible from C#.","date":"2024-05-06T00:00:00.000Z","tags":[{"label":"fable","permalink":"/Siren/blog/tags/fable"},{"label":"library","permalink":"/Siren/blog/tags/library"},{"label":"api","permalink":"/Siren/blog/tags/api"},{"label":"design","permalink":"/Siren/blog/tags/design"},{"label":"helper","permalink":"/Siren/blog/tags/helper"}],"readingTime":23.63,"hasTruncateMarker":false,"authors":[{"name":"Kevin Frey","title":"Maintainer of Siren","url":"https://github.com/Freymaurer","imageURL":"https://github.com/Freymaurer.png","key":"freyk"}],"frontMatter":{"slug":"Library Design","title":"Library Design","authors":"freyk","tags":["fable","library","api","design","helper"]},"unlisted":false},"content":"import Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\n\\nSiren consists of one main code base written in F#. This code base is then transpiled to JavaScript, TypeScript, Python and made accessible from C#.\\n\\n:::tip[Fable.Multiverse]\\n\\nTo make it as easy as possible to create a Fable library that publishes in multiple languages, I created a template called [Fable.Multiverse](https://github.com/Freymaurer/Fable.Multiverse) :tada:\\n\\n:::\\n\\n## Idea \ud83d\udca1\\n\\nDuring a hackathon for our research data management consortium, we were discussing ideas for visualizing graph like structures in a way that allows easy gitlab integration and can be understood and used by any level of user. The idea we pursued was to add `.md` files with mermaid graphs for an easy overview. So why not write a domain specific language for mermaid graphs to make creation of such graphs easier and more error proof. Good idea, but what programming language should we use? In our consortium we have several groups, some using JavaScript, some Python, some (us) .NET or more specifically F#. Because i already have quite some experience using [Fable][Fable], i did the mental checklist to see if it would be a good fit for this project.\\n\\n- [x] *Does not need any dependencies.* Mermaid graphs, are mostly YAML, so no complex syntax.\\n- [x] *Does not require IO interaction.* We can simply focus on writing our mermaid graph as string and allow the user to do whatever they want with it.\\n- [x] *Only Fable compatible languages needed.* We are already very happy offering such a tool in Python, JavaScript and F#.\\n\\n.. and thats it \ud83c\udf89 So we can start developing a libary with one codebase for 4 [5] languages.\\n\\n## What is Fable?\\n\\nFable is a F# to X transpiler. It started out targeting only JavaScript, using a naming reference to the popular [Babel](https://babeljs.io) JavaScript transpiler. Now Fable aims to support multiple languages, all in different states. At the time of writing, the offical Fable docs state the following:\\n\\n| Language | Status | \\n|---|---|\\n| JavaScript | Stable |\\n| TypeScript |\\tStable| \\n| Dart |\\tBeta| \\n| Python |\\tBeta| \\n| Rust |\\tAlpha| \\n| PHP |\\tExperimental| \\n\\n### Benefits\\n\\n- **Type Safety**. F# is a statically typed language, which means that the compiler can catch many errors before they even happen.\\n- **Lightweight Syntax**. F# has a very lightweight syntax, which makes it easy to read and write. It does not require a lot of boilerplate code and you can get right into the meat of your program.\\n- **Testing(?)**. Main codebase is written in F# as well as most tests. This allows us to also transpile the tests to other languages and run them there. This is a big advantage, as we can be sure that the tests are the same in all languages.\\n\\n:::note[But why the question mark behind testing?]\\n\\nBecause we can recycle the tests, to ensure correct functionality, but we still must test if the library can be used from all supported languages without hurdles.\\n:::\\n\\n## API Design\\n\\nTo make the code look and feel as native as possible in all languages, there are some things we need to consider. But first let us have a look at fable transpiled code.\\n\\n:::info\\nThe following code will use the [Fable REPL][REPL] to transpile code for easy showcasing!\\n:::\\n\\n\\n<Tabs>\\n<TabItem value=\\"fsharp\\" label=\\"F#\\">\\n```fsharp\\nlet helloWorld = printfn \\"Hello World\\"\\n```\\n</TabItem>\\n\\n<TabItem value=\\"js\\" label=\\"JavaScript\\">\\n```js\\nimport { printf, toConsole } from \\"fable-library-js/String.js\\";\\n\\nexport const helloWorld = toConsole(printf(\\"Hello World\\"));\\n```\\n</TabItem>\\n\\n<TabItem value=\\"py\\" label=\\"Python\\">\\n```python\\nfrom fable_library_js.string import (to_console, printf)\\n\\nhello_world: None = to_console(printf(\\"Hello World\\"))\\n```\\n</TabItem>\\n</Tabs>\\n\\nWe can already notice some things:\\n\\n- Fable tries to transpile into native syntax, so for example snake_case in Python and camelCase in JavaScript\\n- Fable has some wrappers for functions which might have native equivalents. In F# `printfn` is used to print to the console, in JavaScript `console.log` and in Python `print`. But Fable uses their own printf function to ensure 100% correct f# transpilation.\\n\\nNext we will have a look at a class with some member functions.\\n\\n<Tabs>\\n<TabItem value=\\"fsharp\\" label=\\"F#\\">\\n```fsharp\\ntype MyClass =\\n    static member add (x: int) (y: int) = x + y\\n```\\n</TabItem>\\n\\n<TabItem value=\\"js\\" label=\\"JavaScript\\">\\n```js\\nimport { class_type } from \\"fable-library-js/Reflection.js\\";\\n\\nexport class MyClass {\\n    constructor() {\\n    }\\n}\\n\\nexport function MyClass_$reflection() {\\n    return class_type(\\"Test.MyClass\\", undefined, MyClass);\\n}\\n\\nexport function MyClass_add(x, y) {\\n    return x + y;\\n}\\n```\\n</TabItem>\\n\\n<TabItem value=\\"py\\" label=\\"Python\\">\\n```python\\nfrom fable_library_js.reflection import (TypeInfo, class_type)\\n\\ndef _expr0() -> TypeInfo:\\n    return class_type(\\"Test.MyClass\\", None, MyClass)\\n\\n\\nclass MyClass:\\n    ...\\n\\nMyClass_reflection = _expr0\\n\\ndef MyClass_add(x: int, y: int) -> int:\\n    return x + y\\n```\\n</TabItem>\\n</Tabs>\\n\\nOh no, this does not look good. Fable does a thing called [*name mangling*](https://fable.io/docs/javascript/features.html#name-mangling). \\nHave a look at the offical docs for a deeper view on this topic.\\nFor now its enought to know, this is done to allow overloading functions in F#.\\n\\n:::info[Edit- Tree-Shaking]\\n[ncave][ncave] pointed also out to me that tree-shaking in JavaScript was facilitated in this way. As it was easier for bundlers to detect import of single functions, rather then unused class members.\\n:::\\n\\n### Using `[<AttachMembers>]`\\n\\nBut we can tell Fable that we know what we are doing and ignore name mangling.\\n\\n<Tabs>\\n<TabItem value=\\"fsharp\\" label=\\"F#\\">\\n```fsharp\\nopen Fable.Core\\n\\n[<AttachMembers>]\\ntype MyClass =\\n    static member add (x: int) (y: int) = x + y\\n```\\n</TabItem>\\n\\n<TabItem value=\\"js\\" label=\\"JavaScript\\">\\n```js\\nimport { class_type } from \\"fable-library-js/Reflection.js\\";\\n\\nexport class MyClass {\\n    constructor() {\\n    }\\n    static add(x, y) {\\n        return x + y;\\n    }\\n}\\n```\\n</TabItem>\\n\\n<TabItem value=\\"py\\" label=\\"Python\\">\\n```python\\nfrom fable_library_js.reflection import (TypeInfo, class_type)\\n\\nclass MyClass:\\n    @staticmethod\\n    def add(x: int, y: int) -> int:\\n        return x + y\\n```\\n</TabItem>\\n</Tabs>\\n\\nThat looks better and allows us to do the following in all 3 languages: `MyClass.add`.\\nThis is the basic design i chose to use for most user facing api. All F#/Fable code not easily usable from other languages is hidden behind a facade like this.\\n\\n### C# Compatibility\\n\\nStrangely enough allowing C# users the same ease of use as Python and JavaScript users is the hardest. \\nThis is because C# has some issues with F# *optional parameters* and F# *tuples*.\\n\\nIn F# we can define a function like this:\\n\\n```fsharp\\n[<AttachMembers>]\\ntype flowchart =\\n    static member raw (txt: string) = FlowchartElement txt\\n    static member id (txt: string) = FlowchartElement txt\\n    static member node (id: string, ?name: string) : FlowchartElement = ...\\n\\nflowchart.node(\\"My id\\")\\nflowchart.node(\\"My id\\", \\"My name\\")\\n```\\n\\nUsing the F# function in C# will result in an error, when you try to do `flowchart.node(\\"My id\\")`, as `?name` is a `Microsoft.FSharp.Core.FSharpOption<string>` without any default information.\\n\\nBy creating a C# access layer we can avoid this issue for C# users:\\n\\n:::info\\nThe C# extensions for optional parameters and tuples are taken from [Plotly.NET](https://github.com/plotly/Plotly.NET) with the help from my dear colleague [Kevin Schneider][KevinS].\\n:::\\n\\n<Tabs>\\n<TabItem value=\\"flow\\" label=\\"Flowchart.cs\\">\\n```csharp\\npublic static class flowchart\\n{\\n    public static FlowchartElement raw(string txt) => Siren.flowchart.raw(txt);\\n\\n    public static FlowchartElement id(string txt) => Siren.flowchart.raw(txt);\\n\\n    public static FlowchartElement node(string id, Optional<string> name = default) =>\\n        Siren.flowchart.node(id, name.ToOption());\\n    //...\\n}\\n```\\n</TabItem>\\n\\n<TabItem value=\\"fsharp\\" label=\\"OptionExtension.cs\\">\\n```csharp\\n/// <summary>\\n/// Helper type for handling the special way the Plotly.NET core API uses generics.\\n/// In short, the problem arises because many optional parameters of Plotly.NET\'s core API are generics \\n/// with a type constraint for `IConvertible`. This means that these parameters can be both value and reference types \\n/// (e.g. `double` and `System.DateTime` both implement IConvertible).\\n/// If we now have a optional parameter of type `T? where T: IConvertible` the compiler will not allow this \\n/// without further type constrainst to eithe reference or value type.\\n/// This is a problem because we want to 1. allow both, and 2. have a reliable way of determining if the value was not set \\n/// because the F# API expects to be passed `Option.None` in that case.\\n/// There exist other workarounds like checking if the value is default or null, but that changes valid default values actually set to null as well.\\n/// </summary>\\n/// <typeparam name=\\"T\\"></typeparam>\\n/// <param name=\\"Value\\">The value to mark as optional</param>\\n/// <param name=\\"IsSome\\">Wether or not the wrapped value is valid. This is used downstream to determine wether to wrap this value into `Option.Some` (if true) or `Option.None` (if false)</param>\\npublic readonly record struct Optional<T>(T Value, bool IsSome)\\n{\\n    /// <summary>\\n    /// \\n    /// </summary>\\n    /// <param name=\\"Value\\"></param>\\n    public static implicit operator Optional<T>(T Value) => new(Value, true);\\n\\n}\\n/// <summary>\\n/// Extension methods for the `Optional` class\\n/// </summary>\\npublic static class OptionalExtensions\\n{\\n    /// <summary>\\n    /// Converts the `Optional` value to `Some(value)` if the value is valid, or `None` if it is not.\\n    /// </summary>\\n    /// <typeparam name=\\"T\\"></typeparam>\\n    /// <param name=\\"opt\\">The `Optional` value to convert to a F# Option</param>\\n    /// <returns>opt converted to `Option`</returns>\\n    static internal Microsoft.FSharp.Core.FSharpOption<T> ToOption<T>(this Optional<T> opt) => opt.IsSome ? new(opt.Value) : Microsoft.FSharp.Core.FSharpOption<T>.None;\\n}\\n```\\n</TabItem>\\n</Tabs>\\n\\nA similar issue arises with F# tuples:\\n\\n<Tabs>\\n<TabItem value=\\"flow\\" label=\\"Flowchart.fs\\">\\n```fsharp\\n[<AttachMembers>]\\ntype flowchart =\\n    static member stylesNode (nodeId: string, styles:#seq<string*string>) = Flowchart.formatNodeStyles [nodeId] (List.ofSeq styles) |> FlowchartElement\\n```\\n</TabItem>\\n\\n<TabItem value=\\"extension\\" label=\\"TupleExtension.cs\\">\\n```csharp\\n/// <summary>\\n/// Convenience to convert from C# struct tuple literals to the value tuple ones.\\n/// </summary>\\ninternal static class TupleExtensions\\n{\\n    /// <summary>\\n    /// Converts a tuple.\\n    /// </summary>\\n    internal static Tuple<T1, T2> ToTuple<T1, T2>(this ValueTuple<T1, T2> t) => Tuple.Create(t.Item1, t.Item2);\\n}\\n```\\n</TabItem>\\n\\n<TabItem value=\\"fsharp\\" label=\\"Flowchart.cs\\">\\n```csharp\\n/// <summary>\\n/// Convenience to convert from C# struct tuple literals to the value tuple ones.\\n/// </summary>\\npublic static class flowchart\\n{\\n    public static FlowchartElement stylesNode(string nodeId, (string, string)[] styles) =>\\n        Siren.flowchart.stylesNode(nodeId, styles.Select(t => t.ToTuple()));\\n}\\n```\\n</TabItem>\\n</Tabs>\\n\\n#### Code generator helper\\n\\nThese incompatibilities are not only annoying but providing a consistently native C# experience, requires a wrapping for all apis.\\nTo make this easier, i created a code generator that takes a F# file and generates the C# wrapper for it. .. Or at least 95% of it. The rest is done by hand.\\n\\n<details>\\n<summary>Code Generator</summary>\\n<div>\\n```fsharp\\nopen System.Reflection\\n\\n[<LiteralAttribute>]\\nlet FSharpOptionDefault = \\"Optional<string>\\"\\n\\nlet transformParameterTypeName (paramTypeName: string)=\\n    match paramTypeName with\\n    | \\"String\\" -> \\"string\\"\\n    | \\"Int32\\" -> \\"int\\"\\n    | \\"Double\\" -> \\"double\\"\\n    | \\"FSharpOption`1\\" -> FSharpOptionDefault // this is not always true but a good approximation\\n    | \\"Tuple`2\\" -> \\"(string,string)\\" // this is not always true but a good approximation\\n    | \\"Boolean\\" -> \\"bool\\"\\n    | _ -> paramTypeName\\n\\ntype ParameterInfo = {\\n    Type: string\\n    Name: string\\n} with\\n    member this.FSharpParam =\\n        match this with\\n        | {Type = FSharpOptionDefault} -> this.Name + \\".ToOption()\\"\\n        | _ -> this.Name\\n    member this.CSharpParam =\\n       match this with\\n       | {Type = FSharpOptionDefault} -> sprintf \\"%s %s = default\\" this.Type this.Name\\n       | _ -> sprintf \\"%s %s\\" this.Type this.Name\\n\\n    static member create(typeName: string, name: string) =\\n        {Type = transformParameterTypeName typeName; Name = name}\\n\\nlet generateCSharpCode<\'A>() =\\n\\n    let t = typeof<\'A>\\n    let members = t.GetMethods(BindingFlags.Static ||| BindingFlags.Public)\\n\\n    let mutable csharpCode = sprintf \\"public static class %s\\\\n{\\\\n\\" t.Name\\n    for m in members do\\n        let methodName = \\n            let name0 = m.Name\\n            if name0.StartsWith(\\"get_\\") then\\n                name0.Substring(4)\\n            else\\n                name0\\n        let returnType = m.ReturnType.Name\\n        let params0 = \\n            m.GetParameters() \\n            |> Array.map (fun p -> ParameterInfo.create(p.ParameterType.Name, p.Name))\\n        let csharpParameters =\\n            if params0.Length = 0 then\\n                \\"\\"\\n            else    \\n                params0\\n                |> Array.map _.CSharpParam\\n                |> String.concat(\\", \\")\\n                |> fun s -> \\"(\\" + s + \\")\\"\\n        \\n        let fsharpParameters = \\n            if params0.Length = 0 then\\n                \\"\\"\\n            else    \\n                params0 \\n                |> Array.map _.FSharpParam\\n                |> String.concat(\\", \\")\\n                |> fun s -> \\"(\\" + s + \\")\\"\\n        \\n        let methodSignature = $\\"public static {transformParameterTypeName returnType} {methodName}{csharpParameters}\\"\\n        let methodBody = \\n            if methodName.StartsWith(\\"get_\\") then\\n                let withoutGet = methodName.Substring(4)\\n                $\\"return Siren.{t.Name}.{withoutGet};\\"\\n            else\\n                $\\" => Siren.{t.Name}.{methodName}{fsharpParameters};\\"\\n        csharpCode <- csharpCode + $\\"    {methodSignature}\\\\n        {methodBody}\\\\n\\"\\n\\n    csharpCode <- csharpCode + \\"}\\\\n\\"\\n    csharpCode\\n\\nlet test() = \\n    generateCSharpCode<Siren.classDiagram>() // Here you can pass any type you want to generate C# code for\\n    |> printfn \\"%A\\"\\n```\\n</div>\\n</details>\\n\\nThis is something i did not want to spend a lot of time on, so when i quickly wrote this and noticed it was able to create most of the C# code correctly.\\nI think improving this code to create everything perfectly would be awesome, but would have taken me longer thant fixing the few mistakes it makes by hand.\\n\\n#### Maintainability\\n\\nThis is a big issue. Whenever i update my f# api i must also update the c# wrapper.\\nChanges are mostly catched by the compiler but missings functions are not.\\n\\nThat is why i added unit tests to check the count and name of a c# and f# class and compare it for equality:\\n\\n```csharp\\npublic static class Utils\\n{\\n    public static int GetMemberCount(Type type)\\n    {\\n        var members = type.GetMembers();\\n        return members.Length;\\n    }\\n\\n    public static List<string> GetMemberNameDifferences(Type type1, Type type2)\\n    {\\n        List<string> differences = new List<string>();\\n        //transform string to lower\\n        var type1Members = type1.GetMembers().Select(m => m.Name.ToLower());\\n        var type2Members = type2.GetMembers().Select(m => m.Name.ToLower());\\n        differences.AddRange(type1Members.Except(type2Members));\\n        differences.AddRange(type2Members.Except(type1Members));\\n\\n        return differences;\\n    }\\n\\n    public static void CompareClasses(Type csharpType, Type fsharpType)\\n    {\\n        int csharpMemberCount = GetMemberCount(csharpType);\\n        int fsharpMemberCount = GetMemberCount(fsharpType);\\n        List<string> differences = GetMemberNameDifferences(fsharpType, csharpType);\\n\\n        Assert.Empty(differences);\\n        Assert.Equal(fsharpMemberCount, csharpMemberCount);\\n    }\\n}\\n```\\n\\nThis at least helps me to catch missing functions in the c# wrapper, even if i still have to write them by hand.\\n\\n### Python/JavaScript import and Index files\\n\\nF# and C# use namespaces to organize code. I can have multiple files with the same namespace and access all functions simply by writing `open Siren`/`using Siren.Sea;`.\\n\\nIn Python and JavaScript this is not possible. Here imports happen on a file basis. So i needed to have a single file that imports all other files and exports them.\\n\\nLuckily this file can be created automatically!\\n\\n<details>\\n<summary>Index File</summary>\\n<div>\\n<Tabs>\\n<TabItem value=\\"util\\" label=\\"Util.fs\\">\\n```fsharp\\nmodule Index.Util\\n\\nopen System\\nopen System.IO\\nopen System.Text.RegularExpressions\\n\\ntype FileInformation = {\\n    FilePath : string\\n    Lines : string []\\n} with\\n    static member create(filePath: string, lines: string []) = {\\n        FilePath = filePath\\n        Lines = lines\\n    }\\n\\nlet getAllFiles(path: string, extension: string) = \\n    let options = EnumerationOptions()\\n    options.RecurseSubdirectories <- true\\n    IO.Directory.EnumerateFiles(path,extension,options)\\n    |> Seq.filter (fun s -> s.Contains(\\"fable_modules\\") |> not)\\n    |> Array.ofSeq\\n\\nlet findClasses (rootPath: string) (cois: string []) (regexPattern: string -> string) (filePaths: seq<string>) = \\n    let files = [|\\n        for fp in filePaths do\\n            yield FileInformation.create(fp, System.IO.File.ReadAllLines (fp))\\n    |]\\n    let importStatements = ResizeArray()\\n    let findClass (className: string) = \\n        /// maybe set this as default if you do not want any whitelist\\n        let classNameDefault = @\\"[a-zA-Z_0-9]\\"\\n        let pattern = Regex.Escape(className) |> regexPattern\\n        let regex = Regex(pattern)\\n        let mutable found = false\\n        let mutable result = None\\n        let enum = files.GetEnumerator()\\n        while not found && enum.MoveNext() do\\n            let fileInfo = enum.Current :?> FileInformation\\n            for line in fileInfo.Lines do\\n                let m = regex.Match(line)\\n                match m.Success with\\n                | true -> \\n                    found <- true\\n                    result <- Some <| (className, IO.Path.GetRelativePath(rootPath,fileInfo.FilePath))\\n                | false ->\\n                    ()\\n        match result with\\n        | None ->\\n            failwithf \\"Unable to find %s\\" className\\n        | Some r ->\\n            importStatements.Add r\\n    for coi in cois do findClass coi\\n    importStatements\\n    |> Array.ofSeq\\n\\nlet writeIndexFile (path: string) (fileName: string) (content: string) =\\n    let filePath = Path.Combine(path, fileName)\\n    File.WriteAllText(filePath, content)\\n```\\n</TabItem>\\n\\n<TabItem value=\\"js\\" label=\\"Indexjs.fs\\">\\n```fsharp\\nmodule Index.JS\\n\\nlet private getAllJsFiles (path: string) fileExtension = \\n    Util.getAllFiles(path,$\\"*.{fileExtension}\\")\\n\\nlet private pattern (className: string) = sprintf @\\"^export class (?<ClassName>%s)+[\\\\s{].*({)?\\" className\\n\\nlet private findJsClasses (rootPath: string) (whiteList: string []) (filePaths: string []) = \\n    Util.findClasses rootPath whiteList pattern filePaths\\n\\nopen System.Text\\n\\nlet private createImportStatements (info: (string*string) []) =\\n    let sb = StringBuilder()\\n    let importCollection = info |> Array.groupBy snd |> Array.map (fun (p,a) -> p, a |> Array.map fst )\\n    for filePath, imports in importCollection do\\n        let p = filePath.Replace(\\"\\\\\\\\\\",\\"/\\").Replace(\\"ts\\",\\"js\\")\\n        sb.Append \\"export { \\" |> ignore\\n        sb.AppendJoin(\\", \\", imports) |> ignore\\n        sb.Append \\" } from \\" |> ignore\\n        sb.Append (sprintf \\"\\\\\\"./%s\\\\\\"\\" p) |> ignore\\n        sb.Append \\";\\" |> ignore\\n        sb.AppendLine() |> ignore\\n    sb.ToString()\\n\\nlet private generateIndexfile (rootPath: string, fileName: string, whiteList: string [], fileExtension: string) =\\n    getAllJsFiles rootPath fileExtension\\n    |> findJsClasses rootPath whiteList\\n    |> createImportStatements\\n    |> Util.writeIndexFile rootPath fileName\\n\\nlet generate(rootPath: string) (ts: bool) = \\n    let extension = if ts then \\"ts\\" else \\"js\\"\\n    generateIndexfile(rootPath, $\\"index.{extension}\\", WhiteList.WhiteList, extension)\\n```\\n</TabItem>\\n\\n<TabItem value=\\"py\\" label=\\"Indexpy.fs\\">\\n```fsharp\\nlet private getAllJsFiles(path: string) = \\n    Util.getAllFiles(path,\\"*.py\\")\\n\\nlet private pattern (className: string) = sprintf @\\"^class (?<ClassName>%s)+(\\\\(|:).*$\\" className\\n\\nlet private findPyClasses (rootPath: string) (whiteList: string []) (filePaths: string []) = \\n    Util.findClasses rootPath whiteList pattern filePaths\\n\\nopen System.Text\\n\\nlet private createImportStatements (info: (string*string) []) =\\n    let sb = StringBuilder()\\n    let importCollection = info |> Array.groupBy snd |> Array.map (fun (p,a) -> p, a |> Array.map fst )\\n    for filePath, imports in importCollection do\\n        let p = filePath |> Path.GetFileNameWithoutExtension\\n        sb.Append (sprintf \\"from .%s import \\" p) |> ignore\\n        sb.AppendJoin(\\", \\", imports) |> ignore\\n        sb.AppendLine() |> ignore\\n    sb.ToString()\\n\\nlet private generateIndexfile (rootPath: string, fileName: string, whiteList: string []) =\\n    getAllJsFiles(rootPath)\\n    |> findPyClasses rootPath whiteList\\n    |> createImportStatements\\n    |> Util.writeIndexFile rootPath fileName\\n\\nlet generate(rootPath: string) (name: string) = \\n    // code to make camelcase to snakecase\\n    /// This is because we currently snake_case everything that does not start with a capital letter\\n    let camelCaseToSnakeCase (str: string) = \\n        if Char.IsUpper str.[0] then\\n            str \\n        else\\n            str \\n            |> Seq.fold (fun (acc: string) c -> \\n                if Char.IsUpper c then \\n                    acc + \\"_\\" + string (Char.ToLower c) \\n                else \\n                    acc + string c\\n            ) \\"\\"\\n    let snake_case_white_list = WhiteList.WhiteList |> Array.map camelCaseToSnakeCase\\n    generateIndexfile(rootPath, name, snake_case_white_list)\\n```\\n</TabItem>\\n<TabItem value=\\"whitelist\\" label=\\"WhiteList.fs\\">\\n```fsharp\\nmodule Index.WhiteList\\n\\nlet WhiteList = [|\\n    \\"SirenElement\\"\\n    // ThemeVaruiables\\n    \\"themeVariable\\"\\n    \\"quadrantTheme\\"; \\n    \\"gitTheme\\"; \\n    \\"timelineTheme\\"; \\n    \\"xyChartTheme\\"; \\n    \\"pieTheme\\";\\n    // Config\\n    \\"graphConfig\\";\\n    \\"flowchartConfig\\"; \\n    \\"sequenceConfig\\"; \\n    \\"ganttConfig\\"; \\n    \\"journeyConfig\\"; \\n    \\"timelineConfig\\"; \\n    \\"classConfig\\"; \\n    \\"stateConfig\\"; \\n    \\"erConfig\\"; \\n    \\"quadrantChartConfig\\"; \\n    \\"pieConfig\\"; \\n    \\"sankeyConfig\\"; \\n    \\"xyChartConfig\\"; \\n    \\"mindmapConfig\\"; \\n    \\"gitGraphConfig\\"; \\n    \\"requirementConfig\\"; \\n    // Graphs and Helpers\\n    \\"formatting\\"; \\n    \\"direction\\"; \\n    \\"flowchart\\"; \\n    \\"notePosition\\"; \\n    \\"sequence\\"; \\n    \\"classMemberVisibility\\"; \\n    \\"classMemberClassifier\\"; \\n    \\"classDirection\\"; \\n    \\"classCardinality\\"; \\n    \\"classRltsType\\"; \\n    \\"classDiagram\\"; \\n    \\"stateDiagram\\"; \\n    \\"erKey\\"; \\n    \\"erCardinality\\"; \\n    \\"erDiagram\\"; \\n    \\"journey\\"; \\n    \\"ganttTime\\"; \\n    \\"ganttTags\\"; \\n    \\"ganttUnit\\"; \\n    \\"gantt\\"; \\n    \\"pieChart\\"; \\n    \\"quadrant\\"; \\n    \\"rqRisk\\"; \\n    \\"rqMethod\\"; \\n    \\"requirement\\"; \\n    \\"gitType\\"; \\n    \\"git\\"; \\n    \\"mindmap\\"; \\n    \\"timeline\\"; \\n    \\"sankey\\"; \\n    \\"xyChart\\"; \\n    \\"block\\"; \\n    \\"theme\\"; \\n    \\"siren\\"; \\n|]\\n```\\n</TabItem>\\n</Tabs>\\n\\n</div>\\n</details>\\n\\nThe resulting files look like this:\\n\\n<Tabs>\\n<TabItem value=\\"js\\" label=\\"index.js\\">\\n```js\\nexport { SirenElement } from \\"./SirenTypes.js\\";\\nexport { themeVariable, quadrantTheme, gitTheme, timelineTheme, xyChartTheme, pieTheme } from \\"./ThemeVariables.js\\";\\nexport { graphConfig, flowchartConfig, sequenceConfig, ganttConfig, journeyConfig, timelineConfig, classConfig, stateConfig, erConfig, quadrantChartConfig, pieConfig, sankeyConfig, xyChartConfig, mindmapConfig, gitGraphConfig, requirementConfig } from \\"./Config.js\\";\\nexport { formatting, direction, flowchart, notePosition, sequence, classMemberVisibility, classMemberClassifier, classDirection, classCardinality, classRltsType, classDiagram, stateDiagram, erKey, erCardinality, erDiagram, journey, ganttTime, ganttTags, ganttUnit, gantt, pieChart, quadrant, rqRisk, rqMethod, requirement, gitType, git, mindmap, timeline, sankey, xyChart, block, theme, siren } from \\"./Siren.js\\";\\n```\\n</TabItem>\\n<TabItem value=\\"py\\" label=\\"index.py/__init__.py\\">\\n```py\\nfrom .siren_types import SirenElement\\nfrom .theme_variables import theme_variable, quadrant_theme, git_theme, timeline_theme, xy_chart_theme, pie_theme\\nfrom .config import graph_config, flowchart_config, sequence_config, gantt_config, journey_config, timeline_config, class_config, state_config, er_config, quadrant_chart_config, pie_config, sankey_config, xy_chart_config, mindmap_config, git_graph_config, requirement_config\\nfrom .siren import formatting, direction, flowchart, note_position, sequence, class_member_visibility, class_member_classifier, class_direction, class_cardinality, class_rlts_type, class_diagram, state_diagram, er_key, er_cardinality, er_diagram, journey, gantt_time, gantt_tags, gantt_unit, gantt, pie_chart, quadrant, rq_risk, rq_method, requirement, git_type, git, mindmap, timeline, sankey, xy_chart, block, theme, siren\\n```\\n</TabItem>\\n</Tabs>\\n\\n:::info\\n\\nPython packages will default import whatever is in the `__init__.py` file. So we must simply name the index file for python as such (at least for publishing).\\n\\n:::\\n\\n## Publish\\n\\nAs soon as we get to the publishing step everything is back to standard for the respective languages.\\n\\n### .NET\\n\\nThe easiest. We already have the required project files, no need to transpile. So we can simply use `dotnet pack` to create .nupkg files. \\nThen `dotnet nuget push` to push to [nuget.org](https://www.nuget.org).\\n\\n\\n:::warning\\nThese are not the exact CLI args used. Details can be found in the build project in the GitHub repository.\\n:::\\n\\n### Pypi\\n\\nAlso quite easy. Transpile f# code to python code, copy `pyproject.toml` and `README.md` into the `dist` folder and create `index.py` file. \\nRun `python -m poetry build` to create a publishing files. Then publish files with `python -m poetry publish`\\n\\n:::warning\\nThese are not the exact CLI args used. Details can be found in the build project in the GitHub repository.\\n:::\\n\\n### JavaScript (+Types)\\n\\nFor this i followed the Example of [Better Typed than Sorry](https://fable.io/blog/2023/2023-04-20-Better_Typed_than_Sorry.html) by [Alfonso Garc\xeda-Caro](https://github.com/alfonsogarciacaro).\\n\\nTranspile F# to TypeScript, then use `tsc` to transpile TypeScript to JavaScript and type information files (`*.d.ts`). Add the `index.js` file to the `dist folder`\\nThen publish to npm with `npm publish`.\\n\\n:::warning\\nThese are not the exact CLI args used. Details can be found in the build project in the GitHub repository.\\n:::\\n\\n## Deep Dive\\n\\nFrom here on are some additional issues i encountered during development.\\n\\n### Overloads\\n\\nThe concept of allowing different inputs for the same function exists in f#, as well as python and javascript. \\nBy using the `[<AttachMembers>]` attribute we are not longer allowed to use standard f# overloads. \\nBecause JavaScript does not have the same kind of type interference it is unable to recognice which function should be invoked:\\n\\n<Tabs>\\n<TabItem value=\\"fsharp\\" label=\\"F#\\">\\n```fsharp\\nopen Fable.Core\\n\\n[<AttachMembers>]\\ntype MyClass =\\n    static member add (x: int, y: int) = x * y // this should be invoked\\n    static member add (x: string, y: string) = x + y\\n\\nlet result = MyClass.add(10, 20)\\n\\nprintfn \\"%A\\" result\\n```\\n</TabItem>\\n\\n<TabItem value=\\"js\\" label=\\"JavaScript\\">\\n```js\\nimport { class_type } from \\"fable-library-js/Reflection.js\\";\\nimport { printf, toConsole } from \\"fable-library-js/String.js\\";\\n\\nexport class MyClass {\\n    constructor() {\\n    }\\n    static add(x, y) {\\n        return x * y;\\n    }\\n    static add(x, y) { // This shadows the function above and is invoked\\n        return x + y;\\n    }\\n}\\n\\nexport const result = MyClass.add(10, 20); // This will return 30\\n\\ntoConsole(printf(\\"%A\\"))(result);\\n\\n```\\n</TabItem>\\n</Tabs>\\n\\n#### Erased Unions\\n\\nIt is possible to imitate js overload behaviour by using [erased unions](https://fable.io/docs/javascript/features.html#erased-unions).\\nHere we use a Fable provides discriminate union called ``U2``(``U3``, ``U4``...). After transpilation it is replaced by a js type check.\\n\\n<Tabs>\\n<TabItem value=\\"fsharp\\" label=\\"F#\\">\\n```fsharp\\nopen Fable.Core\\nopen Fable.Core.JsInterop\\n\\n[<AttachMembers>]\\ntype MyClass =\\n    static member test (arg: U2<string, int>) = \\n        match arg with\\n        | U2.Case1 s -> printfn \\"This is a string: %s\\" s\\n        | U2.Case2 i -> printfn \\"This is a integer: %i\\" i\\n\\nlet result = MyClass.test(U2.Case2 10) // or MyClass.test(!^10)\\n\\nprintfn \\"%A\\" result\\n```\\n</TabItem>\\n\\n<TabItem value=\\"js\\" label=\\"JavaScript\\">\\n```js\\nimport { printf, toConsole } from \\"fable-library-js/String.js\\";\\nimport { class_type } from \\"fable-library-js/Reflection.js\\";\\n\\nexport class MyClass {\\n    constructor() {\\n    }\\n    static test(arg) {\\n        if (typeof arg === \\"number\\") {\\n            const i = arg;\\n            toConsole(printf(\\"This is a integer: %i\\"))(i);\\n        }\\n        else {\\n            const s = arg;\\n            toConsole(printf(\\"This is a string: %s\\"))(s);\\n        }\\n    }\\n}\\n\\nexport const result = MyClass.test(10);\\n\\ntoConsole(printf(\\"%A\\"))(); // This is a integer: 10\\n```\\n</TabItem>\\n</Tabs>\\n\\nAs you can see, this looks really nice in JavaScript, but is cumbersome to use in F#. \\n\\nIt would be possible to do do both and use f# overloads and shadow them with the erased union. But this would add more additional maintainance work.\\n\\n:::info[Compiler Statements]\\nWe can use `#if FABLE_COMPILER ... #else ... #endif` syntax to include code only in certain compiler states. \\n\\nIn the following example the erased union is only used (and accessible!) when the code is transpiled by Fable to JavaScript.\\n:::\\n\\n```fsharp\\n[<AttachMembers>]\\ntype MyClass =\\n// highlight-next-line\\n#if FABLE_COMPILER_JAVASCRIPT\\n    static member test (arg: U2<string, int>) = \\n        match arg with\\n        | U2.Case1 s -> printfn \\"This is a string: %s\\" s\\n        | U2.Case2 i -> printfn \\"This is a integer: %i\\" i\\n// highlight-next-line\\n#else\\n    static member test(arg: int) =\\n        printfn \\"This is a integer: %i\\" arg\\n    static member test(arg: string) =\\n        printfn \\"This is a string: %s\\" arg\\n// highlight-next-line\\n#endif\\n\\nlet result = MyClass.test(10)\\n```\\n\\nThis would allow us to use the erased union only in JavaScript and use the F# overloads in F#. But i have not investigated how this would work for python \ud83d\ude05.\\n\\nDue to the additional workload i decided to avoid using overloads in the api. Instead i tried finding the core functions and functions, which allow additional inputs with a different name:\\n\\n```fsharp\\ntype sequence =\\n    static member note(id: string, text: string, ?notePosition: NotePosition) = //..\\n    static member noteSpanning(id1: string, id2, text: string, ?notePosition: NotePosition) = //..\\n```\\n\\n### JavaScript optional parameters\\n\\nUsing functions with multiple optional parameters is easily done in F#, C# and Python, but can get quite annoying in JavaScript:\\n\\n<Tabs>\\n<TabItem value=\\"js\\" label=\\"JavaScript\\">\\n```js\\n// tripple null ...\\nrequirement.requirement(\\"my id\\", null, null, null, rqMethod.test)\\n```\\n</TabItem>\\n\\n<TabItem value=\\"f\\" label=\\"F#\\">\\n```fsharp\\n// easy!\\nrequirement.requirement(\\"My Id\\", rqMethod = rqMethod.analysis)\\n```\\n</TabItem>\\n\\n<TabItem value=\\"py\\" label=\\"Python\\">\\n```python\\n# easy!\\nrequirement.requirement(\\"My Id\\", rq_method = rq_method.analysis)\\n```\\n</TabItem>\\n\\n<TabItem value=\\"c\\" label=\\"C#\\">\\n```csharp\\n// easy!\\nRequirement.requirement(\\"My Id\\", rqMethod: rqMethod.analysis)\\n```\\n</TabItem>\\n</Tabs>\\n\\nThe JavaScript native approach would be using an object with only the values you want to set.\\nThere is even a way to tell Fable to transpile parameters as object using the `[ParamObject]` attribute.\\n\\n<Tabs>\\n<TabItem value=\\"f\\" label=\\"F#\\">\\n```fsharp\\nopen Fable.Core\\nopen Fable.Core.JsInterop\\n\\n[<AttachMembers>]\\ntype MyClass =\\n    [<ParamObject(1)>] // Start creating obj from params at index 1\\n    static member test (name: int, ?id: string, ?text: string, ?rqRisk: string, ?rqMethod: string) =\\n        0\\n\\n\\nMyClass.test(10, rqRisk = \\"Hello\\")\\nMyClass.test(10)\\n```\\n</TabItem>\\n\\n<TabItem value=\\"js\\" label=\\"JavaScript\\">\\n```js\\nimport { class_type } from \\"fable-library-js/Reflection.js\\";\\n\\nexport class MyClass {\\n    constructor() {\\n    }\\n    static test(name, { id, text, rqRisk, rqMethod }) {\\n        return 0;\\n    }\\n}\\n\\nMyClass.test(10, {\\n    rqRisk: \\"Hello\\",\\n});\\n\\nMyClass.test(10, {}); // Oh oh. Why an empty object?\\n```\\n</TabItem>\\n</Tabs>\\n\\nAs you can see adding *no* optional parameters requires an empty object, as Fable checks if the value at object key xyz is null and not if the object is null. \\nWithout the empty object the function would throw an error, whenever any of the optional parameters is referenced in the function. (Bad example as i just return 0).\\n\\n### Member Names \\n\\nDifferent languages have different expectations for member names. Aside from styling best practises, there are some things that are not possible in all languages.\\n\\n:::info\\nF# typically uses PascalCase for class names and camelCase for member names. \\nFor easier usage i ignore this rule and used camelCase for everything.\\n:::\\n\\n#### F# reserved keywords\\n\\nThe first issue i encountered where reserved keywords in F#.\\n\\nFor example ` classDiagram.``class`` `. *\\"class\\"* is a reserved keyword which is not allowed in F#. \\nThe standard solution is wrapping the name in backticks. But at least for me on VisualStudio Community this resulted in issues with my auto complete.\\nThis resulted in me handling this issue inconsistently. The issues i encountered were mostly in (optional) parameters, which is why i changed their names to PascalCase:\\n\\nFor members i mostly stayed true to the backtick syntax.\\n\\n```fsharp\\n[<AttachMembers>]\\ntype classMemberClassifier =\\n    // abstract is a reserved keyword\\n    static member Abstract = ClassMemberClassifier.Abstract\\n    // static is a reserved keyword\\n    static member Static = ClassMemberClassifier.Static\\n    static member custom str = ClassMemberClassifier.Custom str\\n\\n[<AttachMembers>]\\ntype classDiagram =\\n    static member ``class`` (id: string, members: #seq<ClassDiagramElement>) = \\n```\\n\\nThe C# wrapper used the C# best practise syntax `@class`, which worked fine for me.\\n\\n#### C# - Member name = enclosing type\\n\\nI encountered this issue first for `block.block`. In C# member names are not allowed to be the same as the enclosing type.\\n\\nAs i am not a very experienced C# developer, i am still rather undecided on how to handle this issue. \\nSo far I have been using `Block.block`, as I am thinking about using PascalCase for all classes in C#. And if only to mute the warnings in VS Community.\\n\\nIf you have a strong opinion about this topic, please let me know! I am interested in hearing your thoughts.\\n\\n#### Transpiled names\\n\\nAnd back to `classDiagram.``class`` `. While JavaScript does not seem to care about this topic to much, Python does.\\n\\nJavaScript gives us the best result, the F# backtick syntax is transpiled to a simple camelCase name `classDiagram.class`.\\n\\nPython on the other hand has `class` also as reserved keyword. Fable transpiles it to `classDiagram.class_`. \\nWhich raises the question if i should simply apply this syntax to all cases with naming problems.\\n\\n### Docs/Native Test Maintainance\\n\\nThe core library + C# wrapper were done rather quickly. I can also recycle my F# unit tests to check if transpilation works as expected, using [Fable.Pyxpecto](https://github.com/Freymaurer/Fable.Pyxpecto).\\n\\nBut testing correct native accessibillity and writing docs (showcasing the test cases) was the most time consuming part and something i am not happy with.\\n\\nHere are some ideas on how to improve this:\\n\\n- Theoretically, i could use the transpiled tests for docs. But i still have to remove the Fable specific helper functions and replace them with native ones.\\n- *[Kevin S.][KevinS]* had an idea, repurposing jupyter notebooks for docs and testing. To at least unify the testing and docs. \\n\\nIf you have any ideas on how to improve this, please let me know!\\n\\n\\n{/* References */}\\n[Fable]: https://fable.io\\n[REPL]: https://fable.io/repl/\\n[KevinS]: https://github.com/kMutagene\\n[ncave]: https://github.com/ncave"}]}')}}]);